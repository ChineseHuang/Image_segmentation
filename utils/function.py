import numpy as np
class Evaluator(object):
    def __init__(self, num_class):
        self.num_class = num_class
        self.confusion_matrix = np.zeros((self.num_class,) * 2)  # 21*21???,???ground truth??,???preds???,???

    '''
    ????????????
    '''

    def Pixel_Accuracy(self):
        Acc = np.diag(self.confusion_matrix).sum() / self.confusion_matrix.sum()
        return Acc

    '''
    ??????????????
    '''

    def Pixel_Accuracy_Class(self):
        Acc = np.diag(self.confusion_matrix) / self.confusion_matrix.sum(axis=1)
        Acc = np.nanmean(Acc)
        return Acc

    '''
    Mean Intersection over Union(MIoU?????)???????????????????????????.
    ????????????????????ground truth??????predicted segmentation??
    ?????????????intersection?????????????????????????IoU??????

    ??21???,???IOU:
        ??,????1?IOU????:
            (1)???ground truth?????1????
            (2)????????????1????
                (1) + (2)??????????(????????????, ?:?????????????)
                ????????(??ground truth???????????????),??????????(?????1??????:??TP,FP,FN)
        ????:
            TP(??): ????, ???????, ?????  
            FP(??): ????, ???????, ?????
            FN(??): ????, ???????, ?????

            TN(??): ????, ???????, ?????   #???1??,?????????
            (???, ??:???1, ??:????1)

    mIoU:
        ??????????IoU?????

    '''

    def Mean_Intersection_over_Union(self):
        MIoU = np.diag(self.confusion_matrix) / (
                np.sum(self.confusion_matrix, axis=1) + np.sum(self.confusion_matrix, axis=0) -
                np.diag(self.confusion_matrix))
        MIoU = np.nanmean(MIoU)  # ??0??mean,shape:[21]
        return MIoU

    def Class_IOU(self):
        MIoU = np.diag(self.confusion_matrix) / (
                np.sum(self.confusion_matrix, axis=1) + np.sum(self.confusion_matrix, axis=0) -
                np.diag(self.confusion_matrix))
        return MIoU

    def Frequency_Weighted_Intersection_over_Union(self):
        freq = np.sum(self.confusion_matrix, axis=1) / np.sum(self.confusion_matrix)
        iu = np.diag(self.confusion_matrix) / (
                np.sum(self.confusion_matrix, axis=1) + np.sum(self.confusion_matrix, axis=0) -
                np.diag(self.confusion_matrix))

        FWIoU = (freq[freq > 0] * iu[freq > 0]).sum()
        return FWIoU

    '''
    ?????:
        evaluator = Evaluate(4)           #???????4
        evaluator.add_batch(target, preb) #target:[batch_size, 512, 512]    ,    preb:[batch_size, 512, 512]
        ?add_batch?????epoch???????????ground truth?????, ???confusion??(?????mean)


    ??????:
        gt_image: target  ???????            [batch_size, 512, 512]
        per_image: preb   ????????????   [batch_size, 512, 512]

    parameters:
        mask: ground truth?????(??[0, classe_num])???label?mask---????ground truth????????????[0, 20]
        label: ????????, ????????num_class*num_class??, ??label???????0?num_class**2??. [batch_size, 512, 512]
        cout(reshape): ??????????????,???????,????????,count???(x, y)?????????????????x,????y?????
        np.bincount: https://blog.csdn.net/xlinsist/article/details/51346523
        confusion_matrix: ????????????????????(preb?target??),?????????????????????????
    '''

    # ??????
    def _generate_matrix(self, gt_image, pre_image):
        mask = (gt_image >= 0) & (gt_image < self.num_class)  # ground truth?????(??[0, classe_num])???label?mask

        label = self.num_class * gt_image[mask].astype('int') + pre_image[mask]
        # np.bincount????0?n**2-1?n**2?????????????????(n, n)
        count = np.bincount(label, minlength=self.num_class ** 2)
        confusion_matrix = count.reshape(self.num_class, self.num_class)  # 21 * 21(for pascal)
        return confusion_matrix

    # --------------------------------------------------------------------------------

    def add_batch(self, gt_image, pre_image):
        assert gt_image.shape == pre_image.shape
        tmp = self._generate_matrix(gt_image, pre_image)
        # ?????????????,?21*21?????pixel-wise??
        self.confusion_matrix += self._generate_matrix(gt_image, pre_image)

    def reset(self):
        self.confusion_matrix = np.zeros((self.num_class,) * 2)

# if __name__=="__main__":
#     gt_image = np.array([
#         [0, 1, 2, 4],
#         [0, 0, 0, 0],
#         [0, 0, 0, 0],
#         [0, 0, 0, 0]
#     ])
#
#     pre_image = np.array([
#         [0, 1, 2, 4],
#         [0, 1, 0, 0],
#         [0, 1, 0, 0],
#         [0, 0, 1, 0]
#     ])
#     e=Evaluator(num_class=8)
#     e.add_batch(gt_image,pre_image)
#     acc=e.Pixel_Accuracy()
#     print(acc)